diff --git a/src/osdep/amiberry_gfx.cpp b/src/osdep/amiberry_gfx.cpp
index 3253a93..858b6a6 100644
--- a/src/osdep/amiberry_gfx.cpp
+++ b/src/osdep/amiberry_gfx.cpp
@@ -53,12 +53,6 @@
 #include <GL/glew.h>
 #include <SDL_opengl.h>
 
-#define CRTEMU_REPORT_SHADER_ERRORS
-#define CRTEMU_IMPLEMENTATION
-#include "crtemu.h"
-
-#define CRT_FRAME_IMPLEMENTATION
-#include "crt_frame.h"
 
 #endif
 
@@ -75,9 +69,7 @@ SDL_Surface* amiga_surface = nullptr;
 
 #ifdef USE_OPENGL
 SDL_GLContext gl_context;
-//crtemu_t* crtemu_lite = nullptr;
-//crtemu_t* crtemu_pc = nullptr;
-crtemu_t* crtemu_tv = nullptr;
+static GLuint gl_quad_texture = 0;
 #else
 SDL_Texture* amiga_texture;
 #endif
@@ -373,18 +365,11 @@ static bool SDL2_alloctexture(int monid, int w, int h, const int depth)
 	if (w == 0 || h == 0)
 		return false;
 #ifdef USE_OPENGL
-	struct AmigaMonitor* mon = &AMonitors[monid];
-
-	//crt_frame( (CRTEMU_U32*)amiga_surface->pixels ); // bezel - however, seems hardcoded to internal 1024x1024 size
-
-	//TODO Check for option (which CRT filter to use: Lite/PC/TV)
-	if (crtemu_tv)
-		destroy_crtemu();
-	if (crtemu_tv == nullptr)
-		crtemu_tv = crtemu_create(CRTEMU_TYPE_TV, nullptr);
-	if (crtemu_tv)
-		crtemu_frame(crtemu_tv, (CRTEMU_U32*)amiga_surface->pixels, w, h);
-	return crtemu_tv != nullptr;
+	// Direct OpenGL rendering — crtemu not used.
+	// Just confirm the surface exists; actual rendering happens in show_screen().
+	if (w < 0 || h < 0)
+		return true;
+	return amiga_surface != nullptr;
 #else
 	if (w < 0 || h < 0)
 	{
@@ -441,6 +426,28 @@ bool vkbd_allowed(const int monid)
 	return currprefs.vkbd_enabled && !mon->screen_is_picasso;
 }
 
+#ifdef USE_OPENGL
+static bool SDL2_renderframe(const int monid, int mode, int immediate)
+{
+	const amigadisplay* ad = &adisplays[monid];
+	if ((currprefs.leds_on_screen & STATUSLINE_CHIPSET) && !ad->picasso_on)
+	{
+		update_leds(monid);
+	}
+	return amiga_surface != nullptr;
+}
+
+static void SDL2_showframe(const int monid)
+{
+	// OpenGL: presentation happens in show_screen via SDL_GL_SwapWindow
+}
+
+static void SDL2_refresh(const int monid)
+{
+	SDL2_renderframe(monid, 1, 1);
+	show_screen(monid, 0);
+}
+#else
 static bool SDL2_renderframe(const int monid, int mode, int immediate)
 {
 	const AmigaMonitor* mon = &AMonitors[monid];
@@ -476,6 +483,7 @@ static void SDL2_refresh(const int monid)
 	SDL2_renderframe(monid, 1, 1);
 	SDL2_showframe(monid);
 }
+#endif
 #endif //AMIBERRY
 
 int gfx_IsPicassoScreen(const struct AmigaMonitor* mon)
@@ -1141,13 +1149,57 @@ void show_screen(const int monid, int mode)
 		return;
 	}
 #ifdef USE_OPENGL
-	auto time = SDL_GetTicks();
-	glViewport(0, 0, renderQuad.w, renderQuad.h);
-	if (crtemu_tv) {
-		crtemu_present(crtemu_tv, time, (CRTEMU_U32 const*)amiga_surface->pixels,
-			crop_rect.w, crop_rect.h, 0xffffffff, 0x000000);
-	}
+	if (amiga_surface) {
+		Uint32* px = (Uint32*)amiga_surface->pixels;
+		int pitch_px = amiga_surface->pitch / 4;
+		int crop_w = (crop_rect.w > 0 && crop_rect.w <= amiga_surface->w) ? crop_rect.w : 754;
+		int crop_h = (crop_rect.h > 0 && crop_rect.h <= amiga_surface->h) ? crop_rect.h : 574;
+
+		// Fix alpha channel — Wayland compositors require 0xFF for opaque pixels
+		for (int y = crop_rect.y; y < crop_rect.y + crop_h; y++) {
+			Uint32* row = &px[y * pitch_px + crop_rect.x];
+			for (int x = 0; x < crop_w; x++) {
+				row[x] |= 0xFF000000;
+			}
+		}
 
+		int win_w, win_h;
+		SDL_GL_GetDrawableSize(mon->amiga_window, &win_w, &win_h);
+		glViewport(0, 0, win_w, win_h);
+
+		glBindFramebuffer(GL_FRAMEBUFFER, 0);
+		glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+		glClear(GL_COLOR_BUFFER_BIT);
+		glUseProgram(0);
+		glActiveTexture(GL_TEXTURE0);
+
+		if (!gl_quad_texture)
+			glGenTextures(1, &gl_quad_texture);
+		glEnable(GL_TEXTURE_2D);
+		glBindTexture(GL_TEXTURE_2D, gl_quad_texture);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glPixelStorei(GL_UNPACK_ROW_LENGTH, pitch_px);
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8,
+			crop_w, crop_h, 0,
+			GL_BGRA, GL_UNSIGNED_BYTE,
+			&px[crop_rect.y * pitch_px + crop_rect.x]);
+		glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+
+		glMatrixMode(GL_PROJECTION);
+		glLoadIdentity();
+		glOrtho(0, 1, 1, 0, -1, 1);
+		glMatrixMode(GL_MODELVIEW);
+		glLoadIdentity();
+		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+		glBegin(GL_QUADS);
+		glTexCoord2f(0, 0); glVertex2f(0, 0);
+		glTexCoord2f(1, 0); glVertex2f(1, 0);
+		glTexCoord2f(1, 1); glVertex2f(1, 1);
+		glTexCoord2f(0, 1); glVertex2f(0, 1);
+		glEnd();
+		glDisable(GL_TEXTURE_2D);
+	}
 	SDL_GL_SwapWindow(mon->amiga_window);
 #else
 	SDL2_showframe(monid);
@@ -2600,6 +2652,10 @@ void close_windows(struct AmigaMonitor* mon)
 
 #ifdef USE_OPENGL
 	destroy_crtemu();
+	if (gl_quad_texture) {
+		glDeleteTextures(1, &gl_quad_texture);
+		gl_quad_texture = 0;
+	}
 #else
 	if (amiga_texture)
 	{
@@ -2720,9 +2776,9 @@ bool target_graphics_buffer_update(const int monid, const bool force)
 			}
 		}
 #ifdef USE_OPENGL
-		renderQuad = { dx, dy, w, h };
+		render_quad = { dx, dy, w, h };
 		crop_rect = { dx, dy, w, h };
-		set_scaling_option(&currprefs, w, h);
+		set_scaling_option(monid, &currprefs, w, h);
 #else
 		if (mon->amiga_renderer) {
 			if (amiberry_options.rotation_angle == 0 || amiberry_options.rotation_angle == 180) {
@@ -2777,15 +2833,15 @@ bool target_graphics_buffer_update(const int monid, const bool force)
 		}
 #ifdef USE_OPENGL
 		if (!currprefs.gfx_auto_crop && !currprefs.gfx_manual_crop) {
-			renderQuad = { dx, dy, scaled_width, scaled_height };
+			render_quad = { dx, dy, scaled_width, scaled_height };
 			crop_rect = { dx, dy, scaled_width, scaled_height };
 		}
 		else if (currprefs.gfx_manual_crop)
 		{
-			renderQuad = { dx, dy, scaled_width, scaled_height };
+			render_quad = { dx, dy, scaled_width, scaled_height };
 			crop_rect = { currprefs.gfx_horizontal_offset, currprefs.gfx_vertical_offset, currprefs.gfx_manual_crop_width, currprefs.gfx_manual_crop_height };
 		}
-		set_scaling_option(&currprefs, scaled_width, scaled_height);
+		set_scaling_option(monid, &currprefs, scaled_width, scaled_height);
 #else
 		if (mon->amiga_renderer)
 		{
@@ -3044,13 +3100,6 @@ void toggle_fullscreen(const int monid, const int mode)
 
 void destroy_crtemu()
 {
-#ifdef USE_OPENGL
-	if (crtemu_tv != nullptr)
-	{
-		crtemu_destroy(crtemu_tv);
-		crtemu_tv = nullptr;
-	}
-#endif
 }
 
 void graphics_subshutdown()
@@ -3120,7 +3169,7 @@ void auto_crop_image()
 			height = sdl_mode.h;
 		}
 #ifdef USE_OPENGL
-		renderQuad = { dx, dy, width, height };
+		render_quad = { dx, dy, width, height };
 		crop_rect = { cx, cy, cw, ch };
 #else
 
